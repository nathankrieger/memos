// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v4.25.3
// source: api/v1/markdown_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "memos.api.v1";

export enum NodeType {
  NODE_UNSPECIFIED = 0,
  /** LINE_BREAK - Block nodes. */
  LINE_BREAK = 1,
  PARAGRAPH = 2,
  CODE_BLOCK = 3,
  HEADING = 4,
  HORIZONTAL_RULE = 5,
  BLOCKQUOTE = 6,
  LIST = 7,
  ORDERED_LIST_ITEM = 8,
  UNORDERED_LIST_ITEM = 9,
  TASK_LIST_ITEM = 10,
  MATH_BLOCK = 11,
  TABLE = 12,
  EMBEDDED_CONTENT = 13,
  /** TEXT - Inline nodes. */
  TEXT = 51,
  BOLD = 52,
  ITALIC = 53,
  BOLD_ITALIC = 54,
  CODE = 55,
  IMAGE = 56,
  LINK = 57,
  AUTO_LINK = 58,
  TAG = 59,
  STRIKETHROUGH = 60,
  ESCAPING_CHARACTER = 61,
  MATH = 62,
  HIGHLIGHT = 63,
  SUBSCRIPT = 64,
  SUPERSCRIPT = 65,
  REFERENCED_CONTENT = 66,
  SPOILER = 67,
  HTML_ELEMENT = 68,
  UNRECOGNIZED = -1,
}

export function nodeTypeFromJSON(object: any): NodeType {
  switch (object) {
    case 0:
    case "NODE_UNSPECIFIED":
      return NodeType.NODE_UNSPECIFIED;
    case 1:
    case "LINE_BREAK":
      return NodeType.LINE_BREAK;
    case 2:
    case "PARAGRAPH":
      return NodeType.PARAGRAPH;
    case 3:
    case "CODE_BLOCK":
      return NodeType.CODE_BLOCK;
    case 4:
    case "HEADING":
      return NodeType.HEADING;
    case 5:
    case "HORIZONTAL_RULE":
      return NodeType.HORIZONTAL_RULE;
    case 6:
    case "BLOCKQUOTE":
      return NodeType.BLOCKQUOTE;
    case 7:
    case "LIST":
      return NodeType.LIST;
    case 8:
    case "ORDERED_LIST_ITEM":
      return NodeType.ORDERED_LIST_ITEM;
    case 9:
    case "UNORDERED_LIST_ITEM":
      return NodeType.UNORDERED_LIST_ITEM;
    case 10:
    case "TASK_LIST_ITEM":
      return NodeType.TASK_LIST_ITEM;
    case 11:
    case "MATH_BLOCK":
      return NodeType.MATH_BLOCK;
    case 12:
    case "TABLE":
      return NodeType.TABLE;
    case 13:
    case "EMBEDDED_CONTENT":
      return NodeType.EMBEDDED_CONTENT;
    case 51:
    case "TEXT":
      return NodeType.TEXT;
    case 52:
    case "BOLD":
      return NodeType.BOLD;
    case 53:
    case "ITALIC":
      return NodeType.ITALIC;
    case 54:
    case "BOLD_ITALIC":
      return NodeType.BOLD_ITALIC;
    case 55:
    case "CODE":
      return NodeType.CODE;
    case 56:
    case "IMAGE":
      return NodeType.IMAGE;
    case 57:
    case "LINK":
      return NodeType.LINK;
    case 58:
    case "AUTO_LINK":
      return NodeType.AUTO_LINK;
    case 59:
    case "TAG":
      return NodeType.TAG;
    case 60:
    case "STRIKETHROUGH":
      return NodeType.STRIKETHROUGH;
    case 61:
    case "ESCAPING_CHARACTER":
      return NodeType.ESCAPING_CHARACTER;
    case 62:
    case "MATH":
      return NodeType.MATH;
    case 63:
    case "HIGHLIGHT":
      return NodeType.HIGHLIGHT;
    case 64:
    case "SUBSCRIPT":
      return NodeType.SUBSCRIPT;
    case 65:
    case "SUPERSCRIPT":
      return NodeType.SUPERSCRIPT;
    case 66:
    case "REFERENCED_CONTENT":
      return NodeType.REFERENCED_CONTENT;
    case 67:
    case "SPOILER":
      return NodeType.SPOILER;
    case 68:
    case "HTML_ELEMENT":
      return NodeType.HTML_ELEMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeType.UNRECOGNIZED;
  }
}

export function nodeTypeToJSON(object: NodeType): string {
  switch (object) {
    case NodeType.NODE_UNSPECIFIED:
      return "NODE_UNSPECIFIED";
    case NodeType.LINE_BREAK:
      return "LINE_BREAK";
    case NodeType.PARAGRAPH:
      return "PARAGRAPH";
    case NodeType.CODE_BLOCK:
      return "CODE_BLOCK";
    case NodeType.HEADING:
      return "HEADING";
    case NodeType.HORIZONTAL_RULE:
      return "HORIZONTAL_RULE";
    case NodeType.BLOCKQUOTE:
      return "BLOCKQUOTE";
    case NodeType.LIST:
      return "LIST";
    case NodeType.ORDERED_LIST_ITEM:
      return "ORDERED_LIST_ITEM";
    case NodeType.UNORDERED_LIST_ITEM:
      return "UNORDERED_LIST_ITEM";
    case NodeType.TASK_LIST_ITEM:
      return "TASK_LIST_ITEM";
    case NodeType.MATH_BLOCK:
      return "MATH_BLOCK";
    case NodeType.TABLE:
      return "TABLE";
    case NodeType.EMBEDDED_CONTENT:
      return "EMBEDDED_CONTENT";
    case NodeType.TEXT:
      return "TEXT";
    case NodeType.BOLD:
      return "BOLD";
    case NodeType.ITALIC:
      return "ITALIC";
    case NodeType.BOLD_ITALIC:
      return "BOLD_ITALIC";
    case NodeType.CODE:
      return "CODE";
    case NodeType.IMAGE:
      return "IMAGE";
    case NodeType.LINK:
      return "LINK";
    case NodeType.AUTO_LINK:
      return "AUTO_LINK";
    case NodeType.TAG:
      return "TAG";
    case NodeType.STRIKETHROUGH:
      return "STRIKETHROUGH";
    case NodeType.ESCAPING_CHARACTER:
      return "ESCAPING_CHARACTER";
    case NodeType.MATH:
      return "MATH";
    case NodeType.HIGHLIGHT:
      return "HIGHLIGHT";
    case NodeType.SUBSCRIPT:
      return "SUBSCRIPT";
    case NodeType.SUPERSCRIPT:
      return "SUPERSCRIPT";
    case NodeType.REFERENCED_CONTENT:
      return "REFERENCED_CONTENT";
    case NodeType.SPOILER:
      return "SPOILER";
    case NodeType.HTML_ELEMENT:
      return "HTML_ELEMENT";
    case NodeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ParseMarkdownRequest {
  markdown: string;
}

export interface ParseMarkdownResponse {
  nodes: Node[];
}

export interface RestoreMarkdownNodesRequest {
  nodes: Node[];
}

export interface RestoreMarkdownNodesResponse {
  markdown: string;
}

export interface StringifyMarkdownNodesRequest {
  nodes: Node[];
}

export interface StringifyMarkdownNodesResponse {
  plainText: string;
}

export interface GetLinkMetadataRequest {
  link: string;
}

export interface LinkMetadata {
  title: string;
  description: string;
  image: string;
}

export interface Node {
  type: NodeType;
  /** Block nodes. */
  lineBreakNode?: LineBreakNode | undefined;
  paragraphNode?: ParagraphNode | undefined;
  codeBlockNode?: CodeBlockNode | undefined;
  headingNode?: HeadingNode | undefined;
  horizontalRuleNode?: HorizontalRuleNode | undefined;
  blockquoteNode?: BlockquoteNode | undefined;
  listNode?: ListNode | undefined;
  orderedListItemNode?: OrderedListItemNode | undefined;
  unorderedListItemNode?: UnorderedListItemNode | undefined;
  taskListItemNode?: TaskListItemNode | undefined;
  mathBlockNode?: MathBlockNode | undefined;
  tableNode?: TableNode | undefined;
  embeddedContentNode?:
    | EmbeddedContentNode
    | undefined;
  /** Inline nodes. */
  textNode?: TextNode | undefined;
  boldNode?: BoldNode | undefined;
  italicNode?: ItalicNode | undefined;
  boldItalicNode?: BoldItalicNode | undefined;
  codeNode?: CodeNode | undefined;
  imageNode?: ImageNode | undefined;
  linkNode?: LinkNode | undefined;
  autoLinkNode?: AutoLinkNode | undefined;
  tagNode?: TagNode | undefined;
  strikethroughNode?: StrikethroughNode | undefined;
  escapingCharacterNode?: EscapingCharacterNode | undefined;
  mathNode?: MathNode | undefined;
  highlightNode?: HighlightNode | undefined;
  subscriptNode?: SubscriptNode | undefined;
  superscriptNode?: SuperscriptNode | undefined;
  referencedContentNode?: ReferencedContentNode | undefined;
  spoilerNode?: SpoilerNode | undefined;
  htmlElementNode?: HTMLElementNode | undefined;
}

export interface LineBreakNode {
}

export interface ParagraphNode {
  children: Node[];
}

export interface CodeBlockNode {
  language: string;
  content: string;
}

export interface HeadingNode {
  level: number;
  children: Node[];
}

export interface HorizontalRuleNode {
  symbol: string;
}

export interface BlockquoteNode {
  children: Node[];
}

export interface ListNode {
  kind: ListNode_Kind;
  indent: number;
  children: Node[];
}

export enum ListNode_Kind {
  KIND_UNSPECIFIED = 0,
  ORDERED = 1,
  UNORDERED = 2,
  DESCRIPTION = 3,
  UNRECOGNIZED = -1,
}

export function listNode_KindFromJSON(object: any): ListNode_Kind {
  switch (object) {
    case 0:
    case "KIND_UNSPECIFIED":
      return ListNode_Kind.KIND_UNSPECIFIED;
    case 1:
    case "ORDERED":
      return ListNode_Kind.ORDERED;
    case 2:
    case "UNORDERED":
      return ListNode_Kind.UNORDERED;
    case 3:
    case "DESCRIPTION":
      return ListNode_Kind.DESCRIPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListNode_Kind.UNRECOGNIZED;
  }
}

export function listNode_KindToJSON(object: ListNode_Kind): string {
  switch (object) {
    case ListNode_Kind.KIND_UNSPECIFIED:
      return "KIND_UNSPECIFIED";
    case ListNode_Kind.ORDERED:
      return "ORDERED";
    case ListNode_Kind.UNORDERED:
      return "UNORDERED";
    case ListNode_Kind.DESCRIPTION:
      return "DESCRIPTION";
    case ListNode_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OrderedListItemNode {
  number: string;
  indent: number;
  children: Node[];
}

export interface UnorderedListItemNode {
  symbol: string;
  indent: number;
  children: Node[];
}

export interface TaskListItemNode {
  symbol: string;
  indent: number;
  complete: boolean;
  children: Node[];
}

export interface MathBlockNode {
  content: string;
}

export interface TableNode {
  header: Node[];
  delimiter: string[];
  rows: TableNode_Row[];
}

export interface TableNode_Row {
  cells: Node[];
}

export interface EmbeddedContentNode {
  resourceName: string;
  params: string;
}

export interface TextNode {
  content: string;
}

export interface BoldNode {
  symbol: string;
  children: Node[];
}

export interface ItalicNode {
  symbol: string;
  children: Node[];
}

export interface BoldItalicNode {
  symbol: string;
  content: string;
}

export interface CodeNode {
  content: string;
}

export interface ImageNode {
  altText: string;
  url: string;
}

export interface LinkNode {
  content: Node[];
  url: string;
}

export interface AutoLinkNode {
  url: string;
  isRawText: boolean;
}

export interface TagNode {
  content: string;
}

export interface StrikethroughNode {
  content: string;
}

export interface EscapingCharacterNode {
  symbol: string;
}

export interface MathNode {
  content: string;
}

export interface HighlightNode {
  content: string;
}

export interface SubscriptNode {
  content: string;
}

export interface SuperscriptNode {
  content: string;
}

export interface ReferencedContentNode {
  resourceName: string;
  params: string;
}

export interface SpoilerNode {
  content: string;
}

export interface HTMLElementNode {
  tagName: string;
  attributes: { [key: string]: string };
}

export interface HTMLElementNode_AttributesEntry {
  key: string;
  value: string;
}

function createBaseParseMarkdownRequest(): ParseMarkdownRequest {
  return { markdown: "" };
}

export const ParseMarkdownRequest: MessageFns<ParseMarkdownRequest> = {
  encode(message: ParseMarkdownRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.markdown !== "") {
      writer.uint32(10).string(message.markdown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseMarkdownRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseMarkdownRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.markdown = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseMarkdownRequest {
    return { markdown: isSet(object.markdown) ? globalThis.String(object.markdown) : "" };
  },

  toJSON(message: ParseMarkdownRequest): unknown {
    const obj: any = {};
    if (message.markdown !== "") {
      obj.markdown = message.markdown;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParseMarkdownRequest>, I>>(base?: I): ParseMarkdownRequest {
    return ParseMarkdownRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParseMarkdownRequest>, I>>(object: I): ParseMarkdownRequest {
    const message = createBaseParseMarkdownRequest();
    message.markdown = object.markdown ?? "";
    return message;
  },
};

function createBaseParseMarkdownResponse(): ParseMarkdownResponse {
  return { nodes: [] };
}

export const ParseMarkdownResponse: MessageFns<ParseMarkdownResponse> = {
  encode(message: ParseMarkdownResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseMarkdownResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseMarkdownResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseMarkdownResponse {
    return { nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [] };
  },

  toJSON(message: ParseMarkdownResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParseMarkdownResponse>, I>>(base?: I): ParseMarkdownResponse {
    return ParseMarkdownResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParseMarkdownResponse>, I>>(object: I): ParseMarkdownResponse {
    const message = createBaseParseMarkdownResponse();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRestoreMarkdownNodesRequest(): RestoreMarkdownNodesRequest {
  return { nodes: [] };
}

export const RestoreMarkdownNodesRequest: MessageFns<RestoreMarkdownNodesRequest> = {
  encode(message: RestoreMarkdownNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreMarkdownNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreMarkdownNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreMarkdownNodesRequest {
    return { nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [] };
  },

  toJSON(message: RestoreMarkdownNodesRequest): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RestoreMarkdownNodesRequest>, I>>(base?: I): RestoreMarkdownNodesRequest {
    return RestoreMarkdownNodesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RestoreMarkdownNodesRequest>, I>>(object: I): RestoreMarkdownNodesRequest {
    const message = createBaseRestoreMarkdownNodesRequest();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRestoreMarkdownNodesResponse(): RestoreMarkdownNodesResponse {
  return { markdown: "" };
}

export const RestoreMarkdownNodesResponse: MessageFns<RestoreMarkdownNodesResponse> = {
  encode(message: RestoreMarkdownNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.markdown !== "") {
      writer.uint32(10).string(message.markdown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreMarkdownNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreMarkdownNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.markdown = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreMarkdownNodesResponse {
    return { markdown: isSet(object.markdown) ? globalThis.String(object.markdown) : "" };
  },

  toJSON(message: RestoreMarkdownNodesResponse): unknown {
    const obj: any = {};
    if (message.markdown !== "") {
      obj.markdown = message.markdown;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RestoreMarkdownNodesResponse>, I>>(base?: I): RestoreMarkdownNodesResponse {
    return RestoreMarkdownNodesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RestoreMarkdownNodesResponse>, I>>(object: I): RestoreMarkdownNodesResponse {
    const message = createBaseRestoreMarkdownNodesResponse();
    message.markdown = object.markdown ?? "";
    return message;
  },
};

function createBaseStringifyMarkdownNodesRequest(): StringifyMarkdownNodesRequest {
  return { nodes: [] };
}

export const StringifyMarkdownNodesRequest: MessageFns<StringifyMarkdownNodesRequest> = {
  encode(message: StringifyMarkdownNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringifyMarkdownNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringifyMarkdownNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringifyMarkdownNodesRequest {
    return { nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [] };
  },

  toJSON(message: StringifyMarkdownNodesRequest): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StringifyMarkdownNodesRequest>, I>>(base?: I): StringifyMarkdownNodesRequest {
    return StringifyMarkdownNodesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StringifyMarkdownNodesRequest>, I>>(
    object: I,
  ): StringifyMarkdownNodesRequest {
    const message = createBaseStringifyMarkdownNodesRequest();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStringifyMarkdownNodesResponse(): StringifyMarkdownNodesResponse {
  return { plainText: "" };
}

export const StringifyMarkdownNodesResponse: MessageFns<StringifyMarkdownNodesResponse> = {
  encode(message: StringifyMarkdownNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plainText !== "") {
      writer.uint32(10).string(message.plainText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringifyMarkdownNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringifyMarkdownNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plainText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringifyMarkdownNodesResponse {
    return { plainText: isSet(object.plainText) ? globalThis.String(object.plainText) : "" };
  },

  toJSON(message: StringifyMarkdownNodesResponse): unknown {
    const obj: any = {};
    if (message.plainText !== "") {
      obj.plainText = message.plainText;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StringifyMarkdownNodesResponse>, I>>(base?: I): StringifyMarkdownNodesResponse {
    return StringifyMarkdownNodesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StringifyMarkdownNodesResponse>, I>>(
    object: I,
  ): StringifyMarkdownNodesResponse {
    const message = createBaseStringifyMarkdownNodesResponse();
    message.plainText = object.plainText ?? "";
    return message;
  },
};

function createBaseGetLinkMetadataRequest(): GetLinkMetadataRequest {
  return { link: "" };
}

export const GetLinkMetadataRequest: MessageFns<GetLinkMetadataRequest> = {
  encode(message: GetLinkMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.link !== "") {
      writer.uint32(10).string(message.link);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLinkMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLinkMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.link = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLinkMetadataRequest {
    return { link: isSet(object.link) ? globalThis.String(object.link) : "" };
  },

  toJSON(message: GetLinkMetadataRequest): unknown {
    const obj: any = {};
    if (message.link !== "") {
      obj.link = message.link;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLinkMetadataRequest>, I>>(base?: I): GetLinkMetadataRequest {
    return GetLinkMetadataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLinkMetadataRequest>, I>>(object: I): GetLinkMetadataRequest {
    const message = createBaseGetLinkMetadataRequest();
    message.link = object.link ?? "";
    return message;
  },
};

function createBaseLinkMetadata(): LinkMetadata {
  return { title: "", description: "", image: "" };
}

export const LinkMetadata: MessageFns<LinkMetadata> = {
  encode(message: LinkMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.image !== "") {
      writer.uint32(26).string(message.image);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.image = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkMetadata {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      image: isSet(object.image) ? globalThis.String(object.image) : "",
    };
  },

  toJSON(message: LinkMetadata): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkMetadata>, I>>(base?: I): LinkMetadata {
    return LinkMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkMetadata>, I>>(object: I): LinkMetadata {
    const message = createBaseLinkMetadata();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.image = object.image ?? "";
    return message;
  },
};

function createBaseNode(): Node {
  return {
    type: 0,
    lineBreakNode: undefined,
    paragraphNode: undefined,
    codeBlockNode: undefined,
    headingNode: undefined,
    horizontalRuleNode: undefined,
    blockquoteNode: undefined,
    listNode: undefined,
    orderedListItemNode: undefined,
    unorderedListItemNode: undefined,
    taskListItemNode: undefined,
    mathBlockNode: undefined,
    tableNode: undefined,
    embeddedContentNode: undefined,
    textNode: undefined,
    boldNode: undefined,
    italicNode: undefined,
    boldItalicNode: undefined,
    codeNode: undefined,
    imageNode: undefined,
    linkNode: undefined,
    autoLinkNode: undefined,
    tagNode: undefined,
    strikethroughNode: undefined,
    escapingCharacterNode: undefined,
    mathNode: undefined,
    highlightNode: undefined,
    subscriptNode: undefined,
    superscriptNode: undefined,
    referencedContentNode: undefined,
    spoilerNode: undefined,
    htmlElementNode: undefined,
  };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.lineBreakNode !== undefined) {
      LineBreakNode.encode(message.lineBreakNode, writer.uint32(90).fork()).join();
    }
    if (message.paragraphNode !== undefined) {
      ParagraphNode.encode(message.paragraphNode, writer.uint32(98).fork()).join();
    }
    if (message.codeBlockNode !== undefined) {
      CodeBlockNode.encode(message.codeBlockNode, writer.uint32(106).fork()).join();
    }
    if (message.headingNode !== undefined) {
      HeadingNode.encode(message.headingNode, writer.uint32(114).fork()).join();
    }
    if (message.horizontalRuleNode !== undefined) {
      HorizontalRuleNode.encode(message.horizontalRuleNode, writer.uint32(122).fork()).join();
    }
    if (message.blockquoteNode !== undefined) {
      BlockquoteNode.encode(message.blockquoteNode, writer.uint32(130).fork()).join();
    }
    if (message.listNode !== undefined) {
      ListNode.encode(message.listNode, writer.uint32(138).fork()).join();
    }
    if (message.orderedListItemNode !== undefined) {
      OrderedListItemNode.encode(message.orderedListItemNode, writer.uint32(146).fork()).join();
    }
    if (message.unorderedListItemNode !== undefined) {
      UnorderedListItemNode.encode(message.unorderedListItemNode, writer.uint32(154).fork()).join();
    }
    if (message.taskListItemNode !== undefined) {
      TaskListItemNode.encode(message.taskListItemNode, writer.uint32(162).fork()).join();
    }
    if (message.mathBlockNode !== undefined) {
      MathBlockNode.encode(message.mathBlockNode, writer.uint32(170).fork()).join();
    }
    if (message.tableNode !== undefined) {
      TableNode.encode(message.tableNode, writer.uint32(178).fork()).join();
    }
    if (message.embeddedContentNode !== undefined) {
      EmbeddedContentNode.encode(message.embeddedContentNode, writer.uint32(186).fork()).join();
    }
    if (message.textNode !== undefined) {
      TextNode.encode(message.textNode, writer.uint32(410).fork()).join();
    }
    if (message.boldNode !== undefined) {
      BoldNode.encode(message.boldNode, writer.uint32(418).fork()).join();
    }
    if (message.italicNode !== undefined) {
      ItalicNode.encode(message.italicNode, writer.uint32(426).fork()).join();
    }
    if (message.boldItalicNode !== undefined) {
      BoldItalicNode.encode(message.boldItalicNode, writer.uint32(434).fork()).join();
    }
    if (message.codeNode !== undefined) {
      CodeNode.encode(message.codeNode, writer.uint32(442).fork()).join();
    }
    if (message.imageNode !== undefined) {
      ImageNode.encode(message.imageNode, writer.uint32(450).fork()).join();
    }
    if (message.linkNode !== undefined) {
      LinkNode.encode(message.linkNode, writer.uint32(458).fork()).join();
    }
    if (message.autoLinkNode !== undefined) {
      AutoLinkNode.encode(message.autoLinkNode, writer.uint32(466).fork()).join();
    }
    if (message.tagNode !== undefined) {
      TagNode.encode(message.tagNode, writer.uint32(474).fork()).join();
    }
    if (message.strikethroughNode !== undefined) {
      StrikethroughNode.encode(message.strikethroughNode, writer.uint32(482).fork()).join();
    }
    if (message.escapingCharacterNode !== undefined) {
      EscapingCharacterNode.encode(message.escapingCharacterNode, writer.uint32(490).fork()).join();
    }
    if (message.mathNode !== undefined) {
      MathNode.encode(message.mathNode, writer.uint32(498).fork()).join();
    }
    if (message.highlightNode !== undefined) {
      HighlightNode.encode(message.highlightNode, writer.uint32(506).fork()).join();
    }
    if (message.subscriptNode !== undefined) {
      SubscriptNode.encode(message.subscriptNode, writer.uint32(514).fork()).join();
    }
    if (message.superscriptNode !== undefined) {
      SuperscriptNode.encode(message.superscriptNode, writer.uint32(522).fork()).join();
    }
    if (message.referencedContentNode !== undefined) {
      ReferencedContentNode.encode(message.referencedContentNode, writer.uint32(530).fork()).join();
    }
    if (message.spoilerNode !== undefined) {
      SpoilerNode.encode(message.spoilerNode, writer.uint32(538).fork()).join();
    }
    if (message.htmlElementNode !== undefined) {
      HTMLElementNode.encode(message.htmlElementNode, writer.uint32(546).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lineBreakNode = LineBreakNode.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.paragraphNode = ParagraphNode.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.codeBlockNode = CodeBlockNode.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.headingNode = HeadingNode.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.horizontalRuleNode = HorizontalRuleNode.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.blockquoteNode = BlockquoteNode.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.listNode = ListNode.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.orderedListItemNode = OrderedListItemNode.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.unorderedListItemNode = UnorderedListItemNode.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.taskListItemNode = TaskListItemNode.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.mathBlockNode = MathBlockNode.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.tableNode = TableNode.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.embeddedContentNode = EmbeddedContentNode.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.textNode = TextNode.decode(reader, reader.uint32());
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.boldNode = BoldNode.decode(reader, reader.uint32());
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.italicNode = ItalicNode.decode(reader, reader.uint32());
          continue;
        }
        case 54: {
          if (tag !== 434) {
            break;
          }

          message.boldItalicNode = BoldItalicNode.decode(reader, reader.uint32());
          continue;
        }
        case 55: {
          if (tag !== 442) {
            break;
          }

          message.codeNode = CodeNode.decode(reader, reader.uint32());
          continue;
        }
        case 56: {
          if (tag !== 450) {
            break;
          }

          message.imageNode = ImageNode.decode(reader, reader.uint32());
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          message.linkNode = LinkNode.decode(reader, reader.uint32());
          continue;
        }
        case 58: {
          if (tag !== 466) {
            break;
          }

          message.autoLinkNode = AutoLinkNode.decode(reader, reader.uint32());
          continue;
        }
        case 59: {
          if (tag !== 474) {
            break;
          }

          message.tagNode = TagNode.decode(reader, reader.uint32());
          continue;
        }
        case 60: {
          if (tag !== 482) {
            break;
          }

          message.strikethroughNode = StrikethroughNode.decode(reader, reader.uint32());
          continue;
        }
        case 61: {
          if (tag !== 490) {
            break;
          }

          message.escapingCharacterNode = EscapingCharacterNode.decode(reader, reader.uint32());
          continue;
        }
        case 62: {
          if (tag !== 498) {
            break;
          }

          message.mathNode = MathNode.decode(reader, reader.uint32());
          continue;
        }
        case 63: {
          if (tag !== 506) {
            break;
          }

          message.highlightNode = HighlightNode.decode(reader, reader.uint32());
          continue;
        }
        case 64: {
          if (tag !== 514) {
            break;
          }

          message.subscriptNode = SubscriptNode.decode(reader, reader.uint32());
          continue;
        }
        case 65: {
          if (tag !== 522) {
            break;
          }

          message.superscriptNode = SuperscriptNode.decode(reader, reader.uint32());
          continue;
        }
        case 66: {
          if (tag !== 530) {
            break;
          }

          message.referencedContentNode = ReferencedContentNode.decode(reader, reader.uint32());
          continue;
        }
        case 67: {
          if (tag !== 538) {
            break;
          }

          message.spoilerNode = SpoilerNode.decode(reader, reader.uint32());
          continue;
        }
        case 68: {
          if (tag !== 546) {
            break;
          }

          message.htmlElementNode = HTMLElementNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      type: isSet(object.type) ? nodeTypeFromJSON(object.type) : 0,
      lineBreakNode: isSet(object.lineBreakNode) ? LineBreakNode.fromJSON(object.lineBreakNode) : undefined,
      paragraphNode: isSet(object.paragraphNode) ? ParagraphNode.fromJSON(object.paragraphNode) : undefined,
      codeBlockNode: isSet(object.codeBlockNode) ? CodeBlockNode.fromJSON(object.codeBlockNode) : undefined,
      headingNode: isSet(object.headingNode) ? HeadingNode.fromJSON(object.headingNode) : undefined,
      horizontalRuleNode: isSet(object.horizontalRuleNode)
        ? HorizontalRuleNode.fromJSON(object.horizontalRuleNode)
        : undefined,
      blockquoteNode: isSet(object.blockquoteNode) ? BlockquoteNode.fromJSON(object.blockquoteNode) : undefined,
      listNode: isSet(object.listNode) ? ListNode.fromJSON(object.listNode) : undefined,
      orderedListItemNode: isSet(object.orderedListItemNode)
        ? OrderedListItemNode.fromJSON(object.orderedListItemNode)
        : undefined,
      unorderedListItemNode: isSet(object.unorderedListItemNode)
        ? UnorderedListItemNode.fromJSON(object.unorderedListItemNode)
        : undefined,
      taskListItemNode: isSet(object.taskListItemNode) ? TaskListItemNode.fromJSON(object.taskListItemNode) : undefined,
      mathBlockNode: isSet(object.mathBlockNode) ? MathBlockNode.fromJSON(object.mathBlockNode) : undefined,
      tableNode: isSet(object.tableNode) ? TableNode.fromJSON(object.tableNode) : undefined,
      embeddedContentNode: isSet(object.embeddedContentNode)
        ? EmbeddedContentNode.fromJSON(object.embeddedContentNode)
        : undefined,
      textNode: isSet(object.textNode) ? TextNode.fromJSON(object.textNode) : undefined,
      boldNode: isSet(object.boldNode) ? BoldNode.fromJSON(object.boldNode) : undefined,
      italicNode: isSet(object.italicNode) ? ItalicNode.fromJSON(object.italicNode) : undefined,
      boldItalicNode: isSet(object.boldItalicNode) ? BoldItalicNode.fromJSON(object.boldItalicNode) : undefined,
      codeNode: isSet(object.codeNode) ? CodeNode.fromJSON(object.codeNode) : undefined,
      imageNode: isSet(object.imageNode) ? ImageNode.fromJSON(object.imageNode) : undefined,
      linkNode: isSet(object.linkNode) ? LinkNode.fromJSON(object.linkNode) : undefined,
      autoLinkNode: isSet(object.autoLinkNode) ? AutoLinkNode.fromJSON(object.autoLinkNode) : undefined,
      tagNode: isSet(object.tagNode) ? TagNode.fromJSON(object.tagNode) : undefined,
      strikethroughNode: isSet(object.strikethroughNode)
        ? StrikethroughNode.fromJSON(object.strikethroughNode)
        : undefined,
      escapingCharacterNode: isSet(object.escapingCharacterNode)
        ? EscapingCharacterNode.fromJSON(object.escapingCharacterNode)
        : undefined,
      mathNode: isSet(object.mathNode) ? MathNode.fromJSON(object.mathNode) : undefined,
      highlightNode: isSet(object.highlightNode) ? HighlightNode.fromJSON(object.highlightNode) : undefined,
      subscriptNode: isSet(object.subscriptNode) ? SubscriptNode.fromJSON(object.subscriptNode) : undefined,
      superscriptNode: isSet(object.superscriptNode) ? SuperscriptNode.fromJSON(object.superscriptNode) : undefined,
      referencedContentNode: isSet(object.referencedContentNode)
        ? ReferencedContentNode.fromJSON(object.referencedContentNode)
        : undefined,
      spoilerNode: isSet(object.spoilerNode) ? SpoilerNode.fromJSON(object.spoilerNode) : undefined,
      htmlElementNode: isSet(object.htmlElementNode) ? HTMLElementNode.fromJSON(object.htmlElementNode) : undefined,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = nodeTypeToJSON(message.type);
    }
    if (message.lineBreakNode !== undefined) {
      obj.lineBreakNode = LineBreakNode.toJSON(message.lineBreakNode);
    }
    if (message.paragraphNode !== undefined) {
      obj.paragraphNode = ParagraphNode.toJSON(message.paragraphNode);
    }
    if (message.codeBlockNode !== undefined) {
      obj.codeBlockNode = CodeBlockNode.toJSON(message.codeBlockNode);
    }
    if (message.headingNode !== undefined) {
      obj.headingNode = HeadingNode.toJSON(message.headingNode);
    }
    if (message.horizontalRuleNode !== undefined) {
      obj.horizontalRuleNode = HorizontalRuleNode.toJSON(message.horizontalRuleNode);
    }
    if (message.blockquoteNode !== undefined) {
      obj.blockquoteNode = BlockquoteNode.toJSON(message.blockquoteNode);
    }
    if (message.listNode !== undefined) {
      obj.listNode = ListNode.toJSON(message.listNode);
    }
    if (message.orderedListItemNode !== undefined) {
      obj.orderedListItemNode = OrderedListItemNode.toJSON(message.orderedListItemNode);
    }
    if (message.unorderedListItemNode !== undefined) {
      obj.unorderedListItemNode = UnorderedListItemNode.toJSON(message.unorderedListItemNode);
    }
    if (message.taskListItemNode !== undefined) {
      obj.taskListItemNode = TaskListItemNode.toJSON(message.taskListItemNode);
    }
    if (message.mathBlockNode !== undefined) {
      obj.mathBlockNode = MathBlockNode.toJSON(message.mathBlockNode);
    }
    if (message.tableNode !== undefined) {
      obj.tableNode = TableNode.toJSON(message.tableNode);
    }
    if (message.embeddedContentNode !== undefined) {
      obj.embeddedContentNode = EmbeddedContentNode.toJSON(message.embeddedContentNode);
    }
    if (message.textNode !== undefined) {
      obj.textNode = TextNode.toJSON(message.textNode);
    }
    if (message.boldNode !== undefined) {
      obj.boldNode = BoldNode.toJSON(message.boldNode);
    }
    if (message.italicNode !== undefined) {
      obj.italicNode = ItalicNode.toJSON(message.italicNode);
    }
    if (message.boldItalicNode !== undefined) {
      obj.boldItalicNode = BoldItalicNode.toJSON(message.boldItalicNode);
    }
    if (message.codeNode !== undefined) {
      obj.codeNode = CodeNode.toJSON(message.codeNode);
    }
    if (message.imageNode !== undefined) {
      obj.imageNode = ImageNode.toJSON(message.imageNode);
    }
    if (message.linkNode !== undefined) {
      obj.linkNode = LinkNode.toJSON(message.linkNode);
    }
    if (message.autoLinkNode !== undefined) {
      obj.autoLinkNode = AutoLinkNode.toJSON(message.autoLinkNode);
    }
    if (message.tagNode !== undefined) {
      obj.tagNode = TagNode.toJSON(message.tagNode);
    }
    if (message.strikethroughNode !== undefined) {
      obj.strikethroughNode = StrikethroughNode.toJSON(message.strikethroughNode);
    }
    if (message.escapingCharacterNode !== undefined) {
      obj.escapingCharacterNode = EscapingCharacterNode.toJSON(message.escapingCharacterNode);
    }
    if (message.mathNode !== undefined) {
      obj.mathNode = MathNode.toJSON(message.mathNode);
    }
    if (message.highlightNode !== undefined) {
      obj.highlightNode = HighlightNode.toJSON(message.highlightNode);
    }
    if (message.subscriptNode !== undefined) {
      obj.subscriptNode = SubscriptNode.toJSON(message.subscriptNode);
    }
    if (message.superscriptNode !== undefined) {
      obj.superscriptNode = SuperscriptNode.toJSON(message.superscriptNode);
    }
    if (message.referencedContentNode !== undefined) {
      obj.referencedContentNode = ReferencedContentNode.toJSON(message.referencedContentNode);
    }
    if (message.spoilerNode !== undefined) {
      obj.spoilerNode = SpoilerNode.toJSON(message.spoilerNode);
    }
    if (message.htmlElementNode !== undefined) {
      obj.htmlElementNode = HTMLElementNode.toJSON(message.htmlElementNode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.type = object.type ?? 0;
    message.lineBreakNode = (object.lineBreakNode !== undefined && object.lineBreakNode !== null)
      ? LineBreakNode.fromPartial(object.lineBreakNode)
      : undefined;
    message.paragraphNode = (object.paragraphNode !== undefined && object.paragraphNode !== null)
      ? ParagraphNode.fromPartial(object.paragraphNode)
      : undefined;
    message.codeBlockNode = (object.codeBlockNode !== undefined && object.codeBlockNode !== null)
      ? CodeBlockNode.fromPartial(object.codeBlockNode)
      : undefined;
    message.headingNode = (object.headingNode !== undefined && object.headingNode !== null)
      ? HeadingNode.fromPartial(object.headingNode)
      : undefined;
    message.horizontalRuleNode = (object.horizontalRuleNode !== undefined && object.horizontalRuleNode !== null)
      ? HorizontalRuleNode.fromPartial(object.horizontalRuleNode)
      : undefined;
    message.blockquoteNode = (object.blockquoteNode !== undefined && object.blockquoteNode !== null)
      ? BlockquoteNode.fromPartial(object.blockquoteNode)
      : undefined;
    message.listNode = (object.listNode !== undefined && object.listNode !== null)
      ? ListNode.fromPartial(object.listNode)
      : undefined;
    message.orderedListItemNode = (object.orderedListItemNode !== undefined && object.orderedListItemNode !== null)
      ? OrderedListItemNode.fromPartial(object.orderedListItemNode)
      : undefined;
    message.unorderedListItemNode =
      (object.unorderedListItemNode !== undefined && object.unorderedListItemNode !== null)
        ? UnorderedListItemNode.fromPartial(object.unorderedListItemNode)
        : undefined;
    message.taskListItemNode = (object.taskListItemNode !== undefined && object.taskListItemNode !== null)
      ? TaskListItemNode.fromPartial(object.taskListItemNode)
      : undefined;
    message.mathBlockNode = (object.mathBlockNode !== undefined && object.mathBlockNode !== null)
      ? MathBlockNode.fromPartial(object.mathBlockNode)
      : undefined;
    message.tableNode = (object.tableNode !== undefined && object.tableNode !== null)
      ? TableNode.fromPartial(object.tableNode)
      : undefined;
    message.embeddedContentNode = (object.embeddedContentNode !== undefined && object.embeddedContentNode !== null)
      ? EmbeddedContentNode.fromPartial(object.embeddedContentNode)
      : undefined;
    message.textNode = (object.textNode !== undefined && object.textNode !== null)
      ? TextNode.fromPartial(object.textNode)
      : undefined;
    message.boldNode = (object.boldNode !== undefined && object.boldNode !== null)
      ? BoldNode.fromPartial(object.boldNode)
      : undefined;
    message.italicNode = (object.italicNode !== undefined && object.italicNode !== null)
      ? ItalicNode.fromPartial(object.italicNode)
      : undefined;
    message.boldItalicNode = (object.boldItalicNode !== undefined && object.boldItalicNode !== null)
      ? BoldItalicNode.fromPartial(object.boldItalicNode)
      : undefined;
    message.codeNode = (object.codeNode !== undefined && object.codeNode !== null)
      ? CodeNode.fromPartial(object.codeNode)
      : undefined;
    message.imageNode = (object.imageNode !== undefined && object.imageNode !== null)
      ? ImageNode.fromPartial(object.imageNode)
      : undefined;
    message.linkNode = (object.linkNode !== undefined && object.linkNode !== null)
      ? LinkNode.fromPartial(object.linkNode)
      : undefined;
    message.autoLinkNode = (object.autoLinkNode !== undefined && object.autoLinkNode !== null)
      ? AutoLinkNode.fromPartial(object.autoLinkNode)
      : undefined;
    message.tagNode = (object.tagNode !== undefined && object.tagNode !== null)
      ? TagNode.fromPartial(object.tagNode)
      : undefined;
    message.strikethroughNode = (object.strikethroughNode !== undefined && object.strikethroughNode !== null)
      ? StrikethroughNode.fromPartial(object.strikethroughNode)
      : undefined;
    message.escapingCharacterNode =
      (object.escapingCharacterNode !== undefined && object.escapingCharacterNode !== null)
        ? EscapingCharacterNode.fromPartial(object.escapingCharacterNode)
        : undefined;
    message.mathNode = (object.mathNode !== undefined && object.mathNode !== null)
      ? MathNode.fromPartial(object.mathNode)
      : undefined;
    message.highlightNode = (object.highlightNode !== undefined && object.highlightNode !== null)
      ? HighlightNode.fromPartial(object.highlightNode)
      : undefined;
    message.subscriptNode = (object.subscriptNode !== undefined && object.subscriptNode !== null)
      ? SubscriptNode.fromPartial(object.subscriptNode)
      : undefined;
    message.superscriptNode = (object.superscriptNode !== undefined && object.superscriptNode !== null)
      ? SuperscriptNode.fromPartial(object.superscriptNode)
      : undefined;
    message.referencedContentNode =
      (object.referencedContentNode !== undefined && object.referencedContentNode !== null)
        ? ReferencedContentNode.fromPartial(object.referencedContentNode)
        : undefined;
    message.spoilerNode = (object.spoilerNode !== undefined && object.spoilerNode !== null)
      ? SpoilerNode.fromPartial(object.spoilerNode)
      : undefined;
    message.htmlElementNode = (object.htmlElementNode !== undefined && object.htmlElementNode !== null)
      ? HTMLElementNode.fromPartial(object.htmlElementNode)
      : undefined;
    return message;
  },
};

function createBaseLineBreakNode(): LineBreakNode {
  return {};
}

export const LineBreakNode: MessageFns<LineBreakNode> = {
  encode(_: LineBreakNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LineBreakNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineBreakNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LineBreakNode {
    return {};
  },

  toJSON(_: LineBreakNode): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LineBreakNode>, I>>(base?: I): LineBreakNode {
    return LineBreakNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LineBreakNode>, I>>(_: I): LineBreakNode {
    const message = createBaseLineBreakNode();
    return message;
  },
};

function createBaseParagraphNode(): ParagraphNode {
  return { children: [] };
}

export const ParagraphNode: MessageFns<ParagraphNode> = {
  encode(message: ParagraphNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParagraphNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParagraphNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParagraphNode {
    return {
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: ParagraphNode): unknown {
    const obj: any = {};
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParagraphNode>, I>>(base?: I): ParagraphNode {
    return ParagraphNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParagraphNode>, I>>(object: I): ParagraphNode {
    const message = createBaseParagraphNode();
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCodeBlockNode(): CodeBlockNode {
  return { language: "", content: "" };
}

export const CodeBlockNode: MessageFns<CodeBlockNode> = {
  encode(message: CodeBlockNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CodeBlockNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodeBlockNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CodeBlockNode {
    return {
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: CodeBlockNode): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CodeBlockNode>, I>>(base?: I): CodeBlockNode {
    return CodeBlockNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CodeBlockNode>, I>>(object: I): CodeBlockNode {
    const message = createBaseCodeBlockNode();
    message.language = object.language ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseHeadingNode(): HeadingNode {
  return { level: 0, children: [] };
}

export const HeadingNode: MessageFns<HeadingNode> = {
  encode(message: HeadingNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== 0) {
      writer.uint32(8).int32(message.level);
    }
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeadingNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeadingNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.level = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeadingNode {
    return {
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: HeadingNode): unknown {
    const obj: any = {};
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeadingNode>, I>>(base?: I): HeadingNode {
    return HeadingNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeadingNode>, I>>(object: I): HeadingNode {
    const message = createBaseHeadingNode();
    message.level = object.level ?? 0;
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHorizontalRuleNode(): HorizontalRuleNode {
  return { symbol: "" };
}

export const HorizontalRuleNode: MessageFns<HorizontalRuleNode> = {
  encode(message: HorizontalRuleNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HorizontalRuleNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHorizontalRuleNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HorizontalRuleNode {
    return { symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "" };
  },

  toJSON(message: HorizontalRuleNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HorizontalRuleNode>, I>>(base?: I): HorizontalRuleNode {
    return HorizontalRuleNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HorizontalRuleNode>, I>>(object: I): HorizontalRuleNode {
    const message = createBaseHorizontalRuleNode();
    message.symbol = object.symbol ?? "";
    return message;
  },
};

function createBaseBlockquoteNode(): BlockquoteNode {
  return { children: [] };
}

export const BlockquoteNode: MessageFns<BlockquoteNode> = {
  encode(message: BlockquoteNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockquoteNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockquoteNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockquoteNode {
    return {
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: BlockquoteNode): unknown {
    const obj: any = {};
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockquoteNode>, I>>(base?: I): BlockquoteNode {
    return BlockquoteNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockquoteNode>, I>>(object: I): BlockquoteNode {
    const message = createBaseBlockquoteNode();
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListNode(): ListNode {
  return { kind: 0, indent: 0, children: [] };
}

export const ListNode: MessageFns<ListNode> = {
  encode(message: ListNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== 0) {
      writer.uint32(8).int32(message.kind);
    }
    if (message.indent !== 0) {
      writer.uint32(16).int32(message.indent);
    }
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.indent = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNode {
    return {
      kind: isSet(object.kind) ? listNode_KindFromJSON(object.kind) : 0,
      indent: isSet(object.indent) ? globalThis.Number(object.indent) : 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListNode): unknown {
    const obj: any = {};
    if (message.kind !== 0) {
      obj.kind = listNode_KindToJSON(message.kind);
    }
    if (message.indent !== 0) {
      obj.indent = Math.round(message.indent);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNode>, I>>(base?: I): ListNode {
    return ListNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNode>, I>>(object: I): ListNode {
    const message = createBaseListNode();
    message.kind = object.kind ?? 0;
    message.indent = object.indent ?? 0;
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrderedListItemNode(): OrderedListItemNode {
  return { number: "", indent: 0, children: [] };
}

export const OrderedListItemNode: MessageFns<OrderedListItemNode> = {
  encode(message: OrderedListItemNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== "") {
      writer.uint32(10).string(message.number);
    }
    if (message.indent !== 0) {
      writer.uint32(16).int32(message.indent);
    }
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderedListItemNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderedListItemNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.number = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.indent = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderedListItemNode {
    return {
      number: isSet(object.number) ? globalThis.String(object.number) : "",
      indent: isSet(object.indent) ? globalThis.Number(object.indent) : 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: OrderedListItemNode): unknown {
    const obj: any = {};
    if (message.number !== "") {
      obj.number = message.number;
    }
    if (message.indent !== 0) {
      obj.indent = Math.round(message.indent);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderedListItemNode>, I>>(base?: I): OrderedListItemNode {
    return OrderedListItemNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderedListItemNode>, I>>(object: I): OrderedListItemNode {
    const message = createBaseOrderedListItemNode();
    message.number = object.number ?? "";
    message.indent = object.indent ?? 0;
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUnorderedListItemNode(): UnorderedListItemNode {
  return { symbol: "", indent: 0, children: [] };
}

export const UnorderedListItemNode: MessageFns<UnorderedListItemNode> = {
  encode(message: UnorderedListItemNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.indent !== 0) {
      writer.uint32(16).int32(message.indent);
    }
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnorderedListItemNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnorderedListItemNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.indent = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnorderedListItemNode {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      indent: isSet(object.indent) ? globalThis.Number(object.indent) : 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: UnorderedListItemNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.indent !== 0) {
      obj.indent = Math.round(message.indent);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnorderedListItemNode>, I>>(base?: I): UnorderedListItemNode {
    return UnorderedListItemNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnorderedListItemNode>, I>>(object: I): UnorderedListItemNode {
    const message = createBaseUnorderedListItemNode();
    message.symbol = object.symbol ?? "";
    message.indent = object.indent ?? 0;
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTaskListItemNode(): TaskListItemNode {
  return { symbol: "", indent: 0, complete: false, children: [] };
}

export const TaskListItemNode: MessageFns<TaskListItemNode> = {
  encode(message: TaskListItemNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.indent !== 0) {
      writer.uint32(16).int32(message.indent);
    }
    if (message.complete !== false) {
      writer.uint32(24).bool(message.complete);
    }
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskListItemNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskListItemNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.indent = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.complete = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskListItemNode {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      indent: isSet(object.indent) ? globalThis.Number(object.indent) : 0,
      complete: isSet(object.complete) ? globalThis.Boolean(object.complete) : false,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: TaskListItemNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.indent !== 0) {
      obj.indent = Math.round(message.indent);
    }
    if (message.complete !== false) {
      obj.complete = message.complete;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskListItemNode>, I>>(base?: I): TaskListItemNode {
    return TaskListItemNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskListItemNode>, I>>(object: I): TaskListItemNode {
    const message = createBaseTaskListItemNode();
    message.symbol = object.symbol ?? "";
    message.indent = object.indent ?? 0;
    message.complete = object.complete ?? false;
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMathBlockNode(): MathBlockNode {
  return { content: "" };
}

export const MathBlockNode: MessageFns<MathBlockNode> = {
  encode(message: MathBlockNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MathBlockNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMathBlockNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MathBlockNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: MathBlockNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MathBlockNode>, I>>(base?: I): MathBlockNode {
    return MathBlockNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MathBlockNode>, I>>(object: I): MathBlockNode {
    const message = createBaseMathBlockNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseTableNode(): TableNode {
  return { header: [], delimiter: [], rows: [] };
}

export const TableNode: MessageFns<TableNode> = {
  encode(message: TableNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.header) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.delimiter) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.rows) {
      TableNode_Row.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header.push(Node.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.delimiter.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rows.push(TableNode_Row.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableNode {
    return {
      header: globalThis.Array.isArray(object?.header) ? object.header.map((e: any) => Node.fromJSON(e)) : [],
      delimiter: globalThis.Array.isArray(object?.delimiter)
        ? object.delimiter.map((e: any) => globalThis.String(e))
        : [],
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => TableNode_Row.fromJSON(e)) : [],
    };
  },

  toJSON(message: TableNode): unknown {
    const obj: any = {};
    if (message.header?.length) {
      obj.header = message.header.map((e) => Node.toJSON(e));
    }
    if (message.delimiter?.length) {
      obj.delimiter = message.delimiter;
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => TableNode_Row.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TableNode>, I>>(base?: I): TableNode {
    return TableNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TableNode>, I>>(object: I): TableNode {
    const message = createBaseTableNode();
    message.header = object.header?.map((e) => Node.fromPartial(e)) || [];
    message.delimiter = object.delimiter?.map((e) => e) || [];
    message.rows = object.rows?.map((e) => TableNode_Row.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTableNode_Row(): TableNode_Row {
  return { cells: [] };
}

export const TableNode_Row: MessageFns<TableNode_Row> = {
  encode(message: TableNode_Row, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cells) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableNode_Row {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableNode_Row();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cells.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableNode_Row {
    return { cells: globalThis.Array.isArray(object?.cells) ? object.cells.map((e: any) => Node.fromJSON(e)) : [] };
  },

  toJSON(message: TableNode_Row): unknown {
    const obj: any = {};
    if (message.cells?.length) {
      obj.cells = message.cells.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TableNode_Row>, I>>(base?: I): TableNode_Row {
    return TableNode_Row.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TableNode_Row>, I>>(object: I): TableNode_Row {
    const message = createBaseTableNode_Row();
    message.cells = object.cells?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEmbeddedContentNode(): EmbeddedContentNode {
  return { resourceName: "", params: "" };
}

export const EmbeddedContentNode: MessageFns<EmbeddedContentNode> = {
  encode(message: EmbeddedContentNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    if (message.params !== "") {
      writer.uint32(18).string(message.params);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbeddedContentNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbeddedContentNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbeddedContentNode {
    return {
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      params: isSet(object.params) ? globalThis.String(object.params) : "",
    };
  },

  toJSON(message: EmbeddedContentNode): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.params !== "") {
      obj.params = message.params;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbeddedContentNode>, I>>(base?: I): EmbeddedContentNode {
    return EmbeddedContentNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbeddedContentNode>, I>>(object: I): EmbeddedContentNode {
    const message = createBaseEmbeddedContentNode();
    message.resourceName = object.resourceName ?? "";
    message.params = object.params ?? "";
    return message;
  },
};

function createBaseTextNode(): TextNode {
  return { content: "" };
}

export const TextNode: MessageFns<TextNode> = {
  encode(message: TextNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: TextNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextNode>, I>>(base?: I): TextNode {
    return TextNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextNode>, I>>(object: I): TextNode {
    const message = createBaseTextNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseBoldNode(): BoldNode {
  return { symbol: "", children: [] };
}

export const BoldNode: MessageFns<BoldNode> = {
  encode(message: BoldNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoldNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoldNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoldNode {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: BoldNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BoldNode>, I>>(base?: I): BoldNode {
    return BoldNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BoldNode>, I>>(object: I): BoldNode {
    const message = createBaseBoldNode();
    message.symbol = object.symbol ?? "";
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseItalicNode(): ItalicNode {
  return { symbol: "", children: [] };
}

export const ItalicNode: MessageFns<ItalicNode> = {
  encode(message: ItalicNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItalicNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItalicNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItalicNode {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: ItalicNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItalicNode>, I>>(base?: I): ItalicNode {
    return ItalicNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItalicNode>, I>>(object: I): ItalicNode {
    const message = createBaseItalicNode();
    message.symbol = object.symbol ?? "";
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBoldItalicNode(): BoldItalicNode {
  return { symbol: "", content: "" };
}

export const BoldItalicNode: MessageFns<BoldItalicNode> = {
  encode(message: BoldItalicNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoldItalicNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoldItalicNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoldItalicNode {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: BoldItalicNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BoldItalicNode>, I>>(base?: I): BoldItalicNode {
    return BoldItalicNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BoldItalicNode>, I>>(object: I): BoldItalicNode {
    const message = createBaseBoldItalicNode();
    message.symbol = object.symbol ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseCodeNode(): CodeNode {
  return { content: "" };
}

export const CodeNode: MessageFns<CodeNode> = {
  encode(message: CodeNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CodeNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodeNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CodeNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: CodeNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CodeNode>, I>>(base?: I): CodeNode {
    return CodeNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CodeNode>, I>>(object: I): CodeNode {
    const message = createBaseCodeNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseImageNode(): ImageNode {
  return { altText: "", url: "" };
}

export const ImageNode: MessageFns<ImageNode> = {
  encode(message: ImageNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.altText !== "") {
      writer.uint32(10).string(message.altText);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.altText = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageNode {
    return {
      altText: isSet(object.altText) ? globalThis.String(object.altText) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: ImageNode): unknown {
    const obj: any = {};
    if (message.altText !== "") {
      obj.altText = message.altText;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageNode>, I>>(base?: I): ImageNode {
    return ImageNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageNode>, I>>(object: I): ImageNode {
    const message = createBaseImageNode();
    message.altText = object.altText ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseLinkNode(): LinkNode {
  return { content: [], url: "" };
}

export const LinkNode: MessageFns<LinkNode> = {
  encode(message: LinkNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.content) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content.push(Node.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkNode {
    return {
      content: globalThis.Array.isArray(object?.content) ? object.content.map((e: any) => Node.fromJSON(e)) : [],
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: LinkNode): unknown {
    const obj: any = {};
    if (message.content?.length) {
      obj.content = message.content.map((e) => Node.toJSON(e));
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkNode>, I>>(base?: I): LinkNode {
    return LinkNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkNode>, I>>(object: I): LinkNode {
    const message = createBaseLinkNode();
    message.content = object.content?.map((e) => Node.fromPartial(e)) || [];
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseAutoLinkNode(): AutoLinkNode {
  return { url: "", isRawText: false };
}

export const AutoLinkNode: MessageFns<AutoLinkNode> = {
  encode(message: AutoLinkNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.isRawText !== false) {
      writer.uint32(16).bool(message.isRawText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoLinkNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoLinkNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isRawText = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoLinkNode {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      isRawText: isSet(object.isRawText) ? globalThis.Boolean(object.isRawText) : false,
    };
  },

  toJSON(message: AutoLinkNode): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.isRawText !== false) {
      obj.isRawText = message.isRawText;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AutoLinkNode>, I>>(base?: I): AutoLinkNode {
    return AutoLinkNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AutoLinkNode>, I>>(object: I): AutoLinkNode {
    const message = createBaseAutoLinkNode();
    message.url = object.url ?? "";
    message.isRawText = object.isRawText ?? false;
    return message;
  },
};

function createBaseTagNode(): TagNode {
  return { content: "" };
}

export const TagNode: MessageFns<TagNode> = {
  encode(message: TagNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: TagNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TagNode>, I>>(base?: I): TagNode {
    return TagNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TagNode>, I>>(object: I): TagNode {
    const message = createBaseTagNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseStrikethroughNode(): StrikethroughNode {
  return { content: "" };
}

export const StrikethroughNode: MessageFns<StrikethroughNode> = {
  encode(message: StrikethroughNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StrikethroughNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrikethroughNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrikethroughNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: StrikethroughNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StrikethroughNode>, I>>(base?: I): StrikethroughNode {
    return StrikethroughNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StrikethroughNode>, I>>(object: I): StrikethroughNode {
    const message = createBaseStrikethroughNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseEscapingCharacterNode(): EscapingCharacterNode {
  return { symbol: "" };
}

export const EscapingCharacterNode: MessageFns<EscapingCharacterNode> = {
  encode(message: EscapingCharacterNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EscapingCharacterNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEscapingCharacterNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EscapingCharacterNode {
    return { symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "" };
  },

  toJSON(message: EscapingCharacterNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EscapingCharacterNode>, I>>(base?: I): EscapingCharacterNode {
    return EscapingCharacterNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EscapingCharacterNode>, I>>(object: I): EscapingCharacterNode {
    const message = createBaseEscapingCharacterNode();
    message.symbol = object.symbol ?? "";
    return message;
  },
};

function createBaseMathNode(): MathNode {
  return { content: "" };
}

export const MathNode: MessageFns<MathNode> = {
  encode(message: MathNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MathNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMathNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MathNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: MathNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MathNode>, I>>(base?: I): MathNode {
    return MathNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MathNode>, I>>(object: I): MathNode {
    const message = createBaseMathNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseHighlightNode(): HighlightNode {
  return { content: "" };
}

export const HighlightNode: MessageFns<HighlightNode> = {
  encode(message: HighlightNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HighlightNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHighlightNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HighlightNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: HighlightNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HighlightNode>, I>>(base?: I): HighlightNode {
    return HighlightNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HighlightNode>, I>>(object: I): HighlightNode {
    const message = createBaseHighlightNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseSubscriptNode(): SubscriptNode {
  return { content: "" };
}

export const SubscriptNode: MessageFns<SubscriptNode> = {
  encode(message: SubscriptNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: SubscriptNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptNode>, I>>(base?: I): SubscriptNode {
    return SubscriptNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptNode>, I>>(object: I): SubscriptNode {
    const message = createBaseSubscriptNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseSuperscriptNode(): SuperscriptNode {
  return { content: "" };
}

export const SuperscriptNode: MessageFns<SuperscriptNode> = {
  encode(message: SuperscriptNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuperscriptNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuperscriptNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuperscriptNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: SuperscriptNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SuperscriptNode>, I>>(base?: I): SuperscriptNode {
    return SuperscriptNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SuperscriptNode>, I>>(object: I): SuperscriptNode {
    const message = createBaseSuperscriptNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseReferencedContentNode(): ReferencedContentNode {
  return { resourceName: "", params: "" };
}

export const ReferencedContentNode: MessageFns<ReferencedContentNode> = {
  encode(message: ReferencedContentNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    if (message.params !== "") {
      writer.uint32(18).string(message.params);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReferencedContentNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReferencedContentNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReferencedContentNode {
    return {
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      params: isSet(object.params) ? globalThis.String(object.params) : "",
    };
  },

  toJSON(message: ReferencedContentNode): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.params !== "") {
      obj.params = message.params;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReferencedContentNode>, I>>(base?: I): ReferencedContentNode {
    return ReferencedContentNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReferencedContentNode>, I>>(object: I): ReferencedContentNode {
    const message = createBaseReferencedContentNode();
    message.resourceName = object.resourceName ?? "";
    message.params = object.params ?? "";
    return message;
  },
};

function createBaseSpoilerNode(): SpoilerNode {
  return { content: "" };
}

export const SpoilerNode: MessageFns<SpoilerNode> = {
  encode(message: SpoilerNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpoilerNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpoilerNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpoilerNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: SpoilerNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpoilerNode>, I>>(base?: I): SpoilerNode {
    return SpoilerNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpoilerNode>, I>>(object: I): SpoilerNode {
    const message = createBaseSpoilerNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseHTMLElementNode(): HTMLElementNode {
  return { tagName: "", attributes: {} };
}

export const HTMLElementNode: MessageFns<HTMLElementNode> = {
  encode(message: HTMLElementNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagName !== "") {
      writer.uint32(10).string(message.tagName);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      HTMLElementNode_AttributesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HTMLElementNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTMLElementNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tagName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = HTMLElementNode_AttributesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.attributes[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HTMLElementNode {
    return {
      tagName: isSet(object.tagName) ? globalThis.String(object.tagName) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: HTMLElementNode): unknown {
    const obj: any = {};
    if (message.tagName !== "") {
      obj.tagName = message.tagName;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HTMLElementNode>, I>>(base?: I): HTMLElementNode {
    return HTMLElementNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HTMLElementNode>, I>>(object: I): HTMLElementNode {
    const message = createBaseHTMLElementNode();
    message.tagName = object.tagName ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseHTMLElementNode_AttributesEntry(): HTMLElementNode_AttributesEntry {
  return { key: "", value: "" };
}

export const HTMLElementNode_AttributesEntry: MessageFns<HTMLElementNode_AttributesEntry> = {
  encode(message: HTMLElementNode_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HTMLElementNode_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTMLElementNode_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HTMLElementNode_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HTMLElementNode_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HTMLElementNode_AttributesEntry>, I>>(base?: I): HTMLElementNode_AttributesEntry {
    return HTMLElementNode_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HTMLElementNode_AttributesEntry>, I>>(
    object: I,
  ): HTMLElementNode_AttributesEntry {
    const message = createBaseHTMLElementNode_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

export interface MarkdownService {
  /** ParseMarkdown parses the given markdown content and returns a list of nodes. */
  ParseMarkdown(request: ParseMarkdownRequest): Promise<ParseMarkdownResponse>;
  /** RestoreMarkdownNodes restores the given nodes to markdown content. */
  RestoreMarkdownNodes(request: RestoreMarkdownNodesRequest): Promise<RestoreMarkdownNodesResponse>;
  /** StringifyMarkdownNodes stringify the given nodes to plain text content. */
  StringifyMarkdownNodes(request: StringifyMarkdownNodesRequest): Promise<StringifyMarkdownNodesResponse>;
  /** GetLinkMetadata returns metadata for a given link. */
  GetLinkMetadata(request: GetLinkMetadataRequest): Promise<LinkMetadata>;
}

export const MarkdownServiceServiceName = "memos.api.v1.MarkdownService";
export class MarkdownServiceClientImpl implements MarkdownService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MarkdownServiceServiceName;
    this.rpc = rpc;
    this.ParseMarkdown = this.ParseMarkdown.bind(this);
    this.RestoreMarkdownNodes = this.RestoreMarkdownNodes.bind(this);
    this.StringifyMarkdownNodes = this.StringifyMarkdownNodes.bind(this);
    this.GetLinkMetadata = this.GetLinkMetadata.bind(this);
  }
  ParseMarkdown(request: ParseMarkdownRequest): Promise<ParseMarkdownResponse> {
    const data = ParseMarkdownRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ParseMarkdown", data);
    return promise.then((data) => ParseMarkdownResponse.decode(new BinaryReader(data)));
  }

  RestoreMarkdownNodes(request: RestoreMarkdownNodesRequest): Promise<RestoreMarkdownNodesResponse> {
    const data = RestoreMarkdownNodesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RestoreMarkdownNodes", data);
    return promise.then((data) => RestoreMarkdownNodesResponse.decode(new BinaryReader(data)));
  }

  StringifyMarkdownNodes(request: StringifyMarkdownNodesRequest): Promise<StringifyMarkdownNodesResponse> {
    const data = StringifyMarkdownNodesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "StringifyMarkdownNodes", data);
    return promise.then((data) => StringifyMarkdownNodesResponse.decode(new BinaryReader(data)));
  }

  GetLinkMetadata(request: GetLinkMetadataRequest): Promise<LinkMetadata> {
    const data = GetLinkMetadataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLinkMetadata", data);
    return promise.then((data) => LinkMetadata.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
